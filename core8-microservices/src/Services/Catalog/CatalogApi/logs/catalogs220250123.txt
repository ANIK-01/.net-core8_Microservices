2025-01-23 08:08:05.904 +00:00 [WRN] Overriding HTTP_PORTS '8080' and HTTPS_PORTS ''. Binding to values defined by URLS instead '"https://+:9999;http://+:9998"'.
2025-01-23 08:08:06.041 +00:00 [WRN] The WebRootPath was not found: /app/wwwroot. Static files may be unavailable.
2025-01-23 08:08:06.055 +00:00 [WRN] Overriding address(es) '"https://+:9999, http://+:9998"'. Binding to endpoints defined via IConfiguration and/or UseKestrel() instead.
2025-01-23 08:08:06.460 +00:00 [INF] Now listening on: http://0.0.0.0:8080
2025-01-23 08:08:06.462 +00:00 [INF] Now listening on: https://0.0.0.0:8081
2025-01-23 08:08:06.464 +00:00 [INF] Application started. Press Ctrl+C to shut down.
2025-01-23 08:08:06.464 +00:00 [INF] Hosting environment: Production
2025-01-23 08:08:06.465 +00:00 [INF] Content root path: /app
2025-01-23 08:08:18.993 +00:00 [INF] Request starting HTTP/1.1 GET http://localhost:9998/ - null null
2025-01-23 08:08:19.165 +00:00 [INF] Executing endpoint 'HTTP: GET /'
2025-01-23 08:08:19.178 +00:00 [INF] Executed endpoint 'HTTP: GET /'
2025-01-23 08:08:19.181 +00:00 [INF] Request finished HTTP/1.1 GET http://localhost:9998/ - 200 null text/plain; charset=utf-8 190.1927ms
2025-01-23 08:08:19.224 +00:00 [INF] Request starting HTTP/1.1 GET http://localhost:9998/favicon.ico - null null
2025-01-23 08:08:19.226 +00:00 [INF] Request finished HTTP/1.1 GET http://localhost:9998/favicon.ico - 404 0 null 2.5642ms
2025-01-23 08:08:19.229 +00:00 [INF] Request reached the end of the middleware pipeline without being handled by application code. Request path: GET http://localhost:9998/favicon.ico, Response status code: 404
2025-01-23 08:08:31.979 +00:00 [INF] Request starting HTTP/1.1 GET http://localhost:9998/ - null null
2025-01-23 08:08:31.980 +00:00 [INF] Executing endpoint 'HTTP: GET /'
2025-01-23 08:08:31.981 +00:00 [INF] Executed endpoint 'HTTP: GET /'
2025-01-23 08:08:31.981 +00:00 [INF] Request finished HTTP/1.1 GET http://localhost:9998/ - 200 null text/plain; charset=utf-8 2.492ms
2025-01-23 08:08:38.551 +00:00 [INF] Request starting HTTP/2 GET https://localhost:9999/ - null null
2025-01-23 08:08:38.552 +00:00 [INF] Executing endpoint 'HTTP: GET /'
2025-01-23 08:08:38.554 +00:00 [INF] Executed endpoint 'HTTP: GET /'
2025-01-23 08:08:38.555 +00:00 [INF] Request finished HTTP/2 GET https://localhost:9999/ - 200 null text/plain; charset=utf-8 24.9835ms
2025-01-23 08:08:38.598 +00:00 [INF] Request starting HTTP/2 GET https://localhost:9999/favicon.ico - null null
2025-01-23 08:08:38.601 +00:00 [INF] Request finished HTTP/2 GET https://localhost:9999/favicon.ico - 404 0 null 2.8624ms
2025-01-23 08:08:38.602 +00:00 [INF] Request reached the end of the middleware pipeline without being handled by application code. Request path: GET https://localhost:9999/favicon.ico, Response status code: 404
2025-01-23 08:09:19.207 +00:00 [INF] Request starting HTTP/1.1 GET https://localhost:9999/products - application/json 269
2025-01-23 08:09:19.209 +00:00 [INF] Executing endpoint 'HTTP: GET /products'
2025-01-23 08:09:26.736 +00:00 [INF] GetProductsQueryHandler.Handle called with {"$type":"GetProductsQuery"}
2025-01-23 08:09:35.854 +00:00 [INF] Batch execution completed (duration=52ms): ["\nSELECT pg_get_functiondef(pg_proc.oid)\nFROM pg_proc JOIN pg_namespace as ns ON pg_proc.pronamespace = ns.oid WHERE ns.nspname = $1 and proname = $2","SELECT format('DROP FUNCTION IF EXISTS %s.%s(%s);'\n             ,n.nspname\n             ,p.proname\n             ,pg_get_function_identity_arguments(p.oid))\nFROM   pg_proc p\nLEFT JOIN pg_catalog.pg_namespace n ON n.oid = p.pronamespace\nWHERE  p.proname = $1\nAND    n.nspname = $2","SELECT pg_get_functiondef(pg_proc.oid)\nFROM pg_proc JOIN pg_namespace as ns ON pg_proc.pronamespace = ns.oid WHERE ns.nspname = $1 and proname = $2","SELECT format('DROP FUNCTION IF EXISTS %s.%s(%s);'\n             ,n.nspname\n             ,p.proname\n             ,pg_get_function_identity_arguments(p.oid))\nFROM   pg_proc p\nLEFT JOIN pg_catalog.pg_namespace n ON n.oid = p.pronamespace\nWHERE  p.proname = $1\nAND    n.nspname = $2","SELECT pg_get_functiondef(pg_proc.oid)\nFROM pg_proc JOIN pg_namespace as ns ON pg_proc.pronamespace = ns.oid WHERE ns.nspname = $1 and proname = $2","SELECT format('DROP FUNCTION IF EXISTS %s.%s(%s);'\n             ,n.nspname\n             ,p.proname\n             ,pg_get_function_identity_arguments(p.oid))\nFROM   pg_proc p\nLEFT JOIN pg_catalog.pg_namespace n ON n.oid = p.pronamespace\nWHERE  p.proname = $1\nAND    n.nspname = $2","SELECT pg_get_functiondef(pg_proc.oid)\nFROM pg_proc JOIN pg_namespace as ns ON pg_proc.pronamespace = ns.oid WHERE ns.nspname = $1 and proname = $2","SELECT format('DROP FUNCTION IF EXISTS %s.%s(%s);'\n             ,n.nspname\n             ,p.proname\n             ,pg_get_function_identity_arguments(p.oid))\nFROM   pg_proc p\nLEFT JOIN pg_catalog.pg_namespace n ON n.oid = p.pronamespace\nWHERE  p.proname = $1\nAND    n.nspname = $2","SELECT pg_get_functiondef(pg_proc.oid)\nFROM pg_proc JOIN pg_namespace as ns ON pg_proc.pronamespace = ns.oid WHERE ns.nspname = $1 and proname = $2","SELECT format('DROP FUNCTION IF EXISTS %s.%s(%s);'\n             ,n.nspname\n             ,p.proname\n             ,pg_get_function_identity_arguments(p.oid))\nFROM   pg_proc p\nLEFT JOIN pg_catalog.pg_namespace n ON n.oid = p.pronamespace\nWHERE  p.proname = $1\nAND    n.nspname = $2","SELECT pg_get_functiondef(pg_proc.oid)\nFROM pg_proc JOIN pg_namespace as ns ON pg_proc.pronamespace = ns.oid WHERE ns.nspname = $1 and proname = $2","SELECT format('DROP FUNCTION IF EXISTS %s.%s(%s);'\n             ,n.nspname\n             ,p.proname\n             ,pg_get_function_identity_arguments(p.oid))\nFROM   pg_proc p\nLEFT JOIN pg_catalog.pg_namespace n ON n.oid = p.pronamespace\nWHERE  p.proname = $1\nAND    n.nspname = $2","SELECT pg_get_functiondef(pg_proc.oid)\nFROM pg_proc JOIN pg_namespace as ns ON pg_proc.pronamespace = ns.oid WHERE ns.nspname = $1 and proname = $2","SELECT format('DROP FUNCTION IF EXISTS %s.%s(%s);'\n             ,n.nspname\n             ,p.proname\n             ,pg_get_function_identity_arguments(p.oid))\nFROM   pg_proc p\nLEFT JOIN pg_catalog.pg_namespace n ON n.oid = p.pronamespace\nWHERE  p.proname = $1\nAND    n.nspname = $2","SELECT pg_get_functiondef(pg_proc.oid)\nFROM pg_proc JOIN pg_namespace as ns ON pg_proc.pronamespace = ns.oid WHERE ns.nspname = $1 and proname = $2","SELECT format('DROP FUNCTION IF EXISTS %s.%s(%s);'\n             ,n.nspname\n             ,p.proname\n             ,pg_get_function_identity_arguments(p.oid))\nFROM   pg_proc p\nLEFT JOIN pg_catalog.pg_namespace n ON n.oid = p.pronamespace\nWHERE  p.proname = $1\nAND    n.nspname = $2","SELECT pg_get_functiondef(pg_proc.oid)\nFROM pg_proc JOIN pg_namespace as ns ON pg_proc.pronamespace = ns.oid WHERE ns.nspname = $1 and proname = $2","SELECT format('DROP FUNCTION IF EXISTS %s.%s(%s);'\n             ,n.nspname\n             ,p.proname\n             ,pg_get_function_identity_arguments(p.oid))\nFROM   pg_proc p\nLEFT JOIN pg_catalog.pg_namespace n ON n.oid = p.pronamespace\nWHERE  p.proname = $1\nAND    n.nspname = $2","SELECT pg_get_functiondef(pg_proc.oid)\nFROM pg_proc JOIN pg_namespace as ns ON pg_proc.pronamespace = ns.oid WHERE ns.nspname = $1 and proname = $2","SELECT format('DROP FUNCTION IF EXISTS %s.%s(%s);'\n             ,n.nspname\n             ,p.proname\n             ,pg_get_function_identity_arguments(p.oid))\nFROM   pg_proc p\nLEFT JOIN pg_catalog.pg_namespace n ON n.oid = p.pronamespace\nWHERE  p.proname = $1\nAND    n.nspname = $2","SELECT pg_get_functiondef(pg_proc.oid)\nFROM pg_proc JOIN pg_namespace as ns ON pg_proc.pronamespace = ns.oid WHERE ns.nspname = $1 and proname = $2","SELECT format('DROP FUNCTION IF EXISTS %s.%s(%s);'\n             ,n.nspname\n             ,p.proname\n             ,pg_get_function_identity_arguments(p.oid))\nFROM   pg_proc p\nLEFT JOIN pg_catalog.pg_namespace n ON n.oid = p.pronamespace\nWHERE  p.proname = $1\nAND    n.nspname = $2","SELECT pg_get_functiondef(pg_proc.oid)\nFROM pg_proc JOIN pg_namespace as ns ON pg_proc.pronamespace = ns.oid WHERE ns.nspname = $1 and proname = $2","SELECT format('DROP FUNCTION IF EXISTS %s.%s(%s);'\n             ,n.nspname\n             ,p.proname\n             ,pg_get_function_identity_arguments(p.oid))\nFROM   pg_proc p\nLEFT JOIN pg_catalog.pg_namespace n ON n.oid = p.pronamespace\nWHERE  p.proname = $1\nAND    n.nspname = $2","SELECT pg_get_functiondef(pg_proc.oid)\nFROM pg_proc JOIN pg_namespace as ns ON pg_proc.pronamespace = ns.oid WHERE ns.nspname = $1 and proname = $2","SELECT format('DROP FUNCTION IF EXISTS %s.%s(%s);'\n             ,n.nspname\n             ,p.proname\n             ,pg_get_function_identity_arguments(p.oid))\nFROM   pg_proc p\nLEFT JOIN pg_catalog.pg_namespace n ON n.oid = p.pronamespace\nWHERE  p.proname = $1\nAND    n.nspname = $2","SELECT pg_get_functiondef(pg_proc.oid)\nFROM pg_proc JOIN pg_namespace as ns ON pg_proc.pronamespace = ns.oid WHERE ns.nspname = $1 and proname = $2","SELECT format('DROP FUNCTION IF EXISTS %s.%s(%s);'\n             ,n.nspname\n             ,p.proname\n             ,pg_get_function_identity_arguments(p.oid))\nFROM   pg_proc p\nLEFT JOIN pg_catalog.pg_namespace n ON n.oid = p.pronamespace\nWHERE  p.proname = $1\nAND    n.nspname = $2","SELECT pg_get_functiondef(pg_proc.oid)\nFROM pg_proc JOIN pg_namespace as ns ON pg_proc.pronamespace = ns.oid WHERE ns.nspname = $1 and proname = $2","SELECT format('DROP FUNCTION IF EXISTS %s.%s(%s);'\n             ,n.nspname\n             ,p.proname\n             ,pg_get_function_identity_arguments(p.oid))\nFROM   pg_proc p\nLEFT JOIN pg_catalog.pg_namespace n ON n.oid = p.pronamespace\nWHERE  p.proname = $1\nAND    n.nspname = $2","SELECT pg_get_functiondef(pg_proc.oid)\nFROM pg_proc JOIN pg_namespace as ns ON pg_proc.pronamespace = ns.oid WHERE ns.nspname = $1 and proname = $2","SELECT format('DROP FUNCTION IF EXISTS %s.%s(%s);'\n             ,n.nspname\n             ,p.proname\n             ,pg_get_function_identity_arguments(p.oid))\nFROM   pg_proc p\nLEFT JOIN pg_catalog.pg_namespace n ON n.oid = p.pronamespace\nWHERE  p.proname = $1\nAND    n.nspname = $2","SELECT pg_get_functiondef(pg_proc.oid)\nFROM pg_proc JOIN pg_namespace as ns ON pg_proc.pronamespace = ns.oid WHERE ns.nspname = $1 and proname = $2","SELECT format('DROP FUNCTION IF EXISTS %s.%s(%s);'\n             ,n.nspname\n             ,p.proname\n             ,pg_get_function_identity_arguments(p.oid))\nFROM   pg_proc p\nLEFT JOIN pg_catalog.pg_namespace n ON n.oid = p.pronamespace\nWHERE  p.proname = $1\nAND    n.nspname = $2"]
2025-01-23 08:09:35.868 +00:00 [INF] Executed schema update SQL:
CREATE
OR REPLACE FUNCTION public.mt_immutable_timestamp(value text) RETURNS timestamp without time zone LANGUAGE sql IMMUTABLE AS
$function$
select value::timestamp

$function$;


CREATE
OR REPLACE FUNCTION public.mt_immutable_timestamptz(value text) RETURNS timestamp with time zone LANGUAGE sql IMMUTABLE AS
$function$
select value::timestamptz

$function$;


CREATE
OR REPLACE FUNCTION public.mt_immutable_time(value text) RETURNS time without time zone LANGUAGE sql IMMUTABLE AS
$function$
select value::time

$function$;


CREATE
OR REPLACE FUNCTION public.mt_immutable_date(value text) RETURNS date LANGUAGE sql IMMUTABLE AS
$function$
select value::date

$function$;


CREATE
OR REPLACE FUNCTION public.mt_grams_vector(text)
        RETURNS tsvector
        LANGUAGE plpgsql
        IMMUTABLE STRICT
AS $function$
BEGIN
RETURN (SELECT array_to_string(public.mt_grams_array($1), ' ') ::tsvector);
END
$function$;


CREATE
OR REPLACE FUNCTION public.mt_grams_query(text)
        RETURNS tsquery
        LANGUAGE plpgsql
        IMMUTABLE STRICT
AS $function$
BEGIN
RETURN (SELECT array_to_string(public.mt_grams_array($1), ' & ') ::tsquery);
END
$function$;


CREATE
OR REPLACE FUNCTION public.mt_grams_array(words text)
        RETURNS text[]
        LANGUAGE plpgsql
        IMMUTABLE STRICT
AS $function$
        DECLARE
result text[];
        DECLARE
word text;
        DECLARE
clean_word text;
BEGIN
                FOREACH
word IN ARRAY string_to_array(words, ' ')
                LOOP
                     clean_word = regexp_replace(word, '[^a-zA-Z0-9]+', '','g');
FOR i IN 1 .. length(clean_word)
                     LOOP
                         result := result || quote_literal(substr(lower(clean_word), i, 1));
                         result
:= result || quote_literal(substr(lower(clean_word), i, 2));
                         result
:= result || quote_literal(substr(lower(clean_word), i, 3));
END LOOP;
END LOOP;

RETURN ARRAY(SELECT DISTINCT e FROM unnest(result) AS a(e) ORDER BY e);
END;
$function$;


CREATE OR REPLACE FUNCTION public.mt_jsonb_append(jsonb, text[], jsonb, boolean)
    RETURNS jsonb
    LANGUAGE plpgsql
AS $function$
DECLARE
    retval ALIAS FOR $1;
    location ALIAS FOR $2;
    val ALIAS FOR $3;
    if_not_exists ALIAS FOR $4;
    tmp_value jsonb;
BEGIN
    tmp_value = retval #> location;
    IF tmp_value IS NOT NULL AND jsonb_typeof(tmp_value) = 'array' THEN
        CASE
            WHEN NOT if_not_exists THEN
                retval = jsonb_set(retval, location, tmp_value || val, FALSE);
            WHEN jsonb_typeof(val) = 'object' AND NOT tmp_value @> jsonb_build_array(val) THEN
                retval = jsonb_set(retval, location, tmp_value || val, FALSE);
            WHEN jsonb_typeof(val) <> 'object' AND NOT tmp_value @> val THEN
                retval = jsonb_set(retval, location, tmp_value || val, FALSE);
            ELSE NULL;
            END CASE;
    END IF;
    RETURN retval;
END;
$function$;


CREATE OR REPLACE FUNCTION public.mt_jsonb_copy(jsonb, text[], text[])
    RETURNS jsonb
    LANGUAGE plpgsql
AS $function$
DECLARE
    retval ALIAS FOR $1;
    src_path ALIAS FOR $2;
    dst_path ALIAS FOR $3;
    tmp_value jsonb;
BEGIN
    tmp_value = retval #> src_path;
    retval = public.mt_jsonb_fix_null_parent(retval, dst_path);
    RETURN jsonb_set(retval, dst_path, tmp_value::jsonb, TRUE);
END;
$function$;


CREATE OR REPLACE FUNCTION public.mt_jsonb_duplicate(jsonb, text[], jsonb)
RETURNS jsonb
LANGUAGE plpgsql
AS $function$
DECLARE
    retval ALIAS FOR $1;
    location ALIAS FOR $2;
    targets ALIAS FOR $3;
    tmp_value jsonb;
    target_path text[];
    target text;
BEGIN
    FOR target IN SELECT jsonb_array_elements_text(targets)
    LOOP
        target_path = public.mt_jsonb_path_to_array(target, '\.');
        retval = public.mt_jsonb_copy(retval, location, target_path);
    END LOOP;

    RETURN retval;
END;
$function$;


CREATE OR REPLACE FUNCTION public.mt_jsonb_fix_null_parent(jsonb, text[])
    RETURNS jsonb
    LANGUAGE plpgsql
AS $function$
DECLARE
retval ALIAS FOR $1;
    dst_path ALIAS FOR $2;
    dst_path_segment text[] = ARRAY[]::text[];
    dst_path_array_length integer;
    i integer = 1;
BEGIN
    dst_path_array_length = array_length(dst_path, 1);
    WHILE i <=(dst_path_array_length - 1)
    LOOP
        dst_path_segment = dst_path_segment || ARRAY[dst_path[i]];
        IF retval #> dst_path_segment = 'null'::jsonb THEN
            retval = jsonb_set(retval, dst_path_segment, '{}'::jsonb, TRUE);
        END IF;
        i = i + 1;
    END LOOP;

    RETURN retval;
END;
$function$;


CREATE OR REPLACE FUNCTION public.mt_jsonb_increment(jsonb, text[], numeric)
    RETURNS jsonb
    LANGUAGE plpgsql
AS $function$
DECLARE
retval ALIAS FOR $1;
    location ALIAS FOR $2;
    increment_value ALIAS FOR $3;
    tmp_value jsonb;
BEGIN
    tmp_value = retval #> location;
    IF tmp_value IS NULL THEN
        tmp_value = to_jsonb(0);
END IF;

RETURN jsonb_set(retval, location, to_jsonb(tmp_value::numeric + increment_value), TRUE);
END;
$function$;


CREATE OR REPLACE FUNCTION public.mt_jsonb_insert(jsonb, text[], jsonb, integer, boolean)
    RETURNS jsonb
    LANGUAGE plpgsql
AS $function$
DECLARE
    retval ALIAS FOR $1;
    location ALIAS FOR $2;
    val ALIAS FOR $3;
    elm_index ALIAS FOR $4;
    if_not_exists ALIAS FOR $5;
    tmp_value jsonb;
BEGIN
    tmp_value = retval #> location;
    IF tmp_value IS NOT NULL AND jsonb_typeof(tmp_value) = 'array' THEN
        IF elm_index IS NULL THEN
            elm_index = jsonb_array_length(tmp_value) + 1;
        END IF;
        CASE
            WHEN NOT if_not_exists THEN
                retval = jsonb_insert(retval, location || elm_index::text, val);
            WHEN jsonb_typeof(val) = 'object' AND NOT tmp_value @> jsonb_build_array(val) THEN
                retval = jsonb_insert(retval, location || elm_index::text, val);
            WHEN jsonb_typeof(val) <> 'object' AND NOT tmp_value @> val THEN
                retval = jsonb_insert(retval, location || elm_index::text, val);
            ELSE NULL;
        END CASE;
    END IF;
    RETURN retval;
END;
$function$;


CREATE OR REPLACE FUNCTION public.mt_jsonb_move(jsonb, text[], text)
    RETURNS jsonb
    LANGUAGE plpgsql
AS $function$
DECLARE
    retval ALIAS FOR $1;
    src_path ALIAS FOR $2;
    dst_name ALIAS FOR $3;
    dst_path text[];
    tmp_value jsonb;
BEGIN
    tmp_value = retval #> src_path;
    retval = retval #- src_path;
    dst_path = src_path;
    dst_path[array_length(dst_path, 1)] = dst_name;
    retval = public.mt_jsonb_fix_null_parent(retval, dst_path);
    RETURN jsonb_set(retval, dst_path, tmp_value, TRUE);
END;
$function$;


CREATE OR REPLACE FUNCTION public.mt_jsonb_path_to_array(text, character)
    RETURNS text[]
    LANGUAGE plpgsql
AS $function$
DECLARE
    location ALIAS FOR $1;
    regex_pattern ALIAS FOR $2;
BEGIN
RETURN regexp_split_to_array(location, regex_pattern)::text[];
END;
$function$;


CREATE OR REPLACE FUNCTION public.mt_jsonb_remove(jsonb, text[], jsonb)
    RETURNS jsonb
    LANGUAGE plpgsql
AS $function$
DECLARE
    retval ALIAS FOR $1;
    location ALIAS FOR $2;
    val ALIAS FOR $3;
    tmp_value jsonb;
BEGIN
    tmp_value = retval #> location;
    IF tmp_value IS NOT NULL AND jsonb_typeof(tmp_value) = 'array' THEN
        tmp_value =(SELECT jsonb_agg(elem)
        FROM jsonb_array_elements(tmp_value) AS elem
        WHERE elem <> val);

        IF tmp_value IS NULL THEN
            tmp_value = '[]'::jsonb;
        END IF;
    END IF;
    RETURN jsonb_set(retval, location, tmp_value, FALSE);
END;
$function$;


CREATE OR REPLACE FUNCTION public.mt_jsonb_patch(jsonb, jsonb)
    RETURNS jsonb
    LANGUAGE plpgsql
AS $function$
DECLARE
    retval ALIAS FOR $1;
    patchset ALIAS FOR $2;
    patch jsonb;
    patch_path text[];
    value jsonb;
BEGIN
    FOR patch IN SELECT * from jsonb_array_elements(patchset)
    LOOP
        patch_path = public.mt_jsonb_path_to_array((patch->>'path')::text, '\.');

        CASE patch->>'type'
            WHEN 'set' THEN
                retval = jsonb_set(retval, patch_path,(patch->'value')::jsonb, TRUE);
        WHEN 'delete' THEN
                retval = retval#-patch_path;
        WHEN 'append' THEN
                retval = public.mt_jsonb_append(retval, patch_path,(patch->'value')::jsonb, FALSE);
        WHEN 'append_if_not_exists' THEN
                retval = public.mt_jsonb_append(retval, patch_path,(patch->'value')::jsonb, TRUE);
        WHEN 'insert' THEN
                retval = public.mt_jsonb_insert(retval, patch_path,(patch->'value')::jsonb,(patch->>'index')::integer, FALSE);
        WHEN 'insert_if_not_exists' THEN
                retval = public.mt_jsonb_insert(retval, patch_path,(patch->'value')::jsonb,(patch->>'index')::integer, TRUE);
        WHEN 'remove' THEN
                retval = public.mt_jsonb_remove(retval, patch_path,(patch->'value')::jsonb);
        WHEN 'duplicate' THEN
                retval = public.mt_jsonb_duplicate(retval, patch_path,(patch->'targets')::jsonb);
        WHEN 'rename' THEN
                retval = public.mt_jsonb_move(retval, patch_path,(patch->>'to')::text);
        WHEN 'increment' THEN
                retval = public.mt_jsonb_increment(retval, patch_path,(patch->>'increment')::numeric);
        WHEN 'increment_float' THEN
                retval = public.mt_jsonb_increment(retval, patch_path,(patch->>'increment')::numeric);
        ELSE NULL;
        END CASE;
    END LOOP;
    RETURN retval;
END;
$function$;



2025-01-23 08:09:35.919 +00:00 [INF] Batch execution completed (duration=46ms): ["CREATE\nOR REPLACE FUNCTION public.mt_immutable_timestamp(value text) RETURNS timestamp without time zone LANGUAGE sql IMMUTABLE AS\n$function$\nselect value::timestamp\n\n$function$","CREATE\nOR REPLACE FUNCTION public.mt_immutable_timestamptz(value text) RETURNS timestamp with time zone LANGUAGE sql IMMUTABLE AS\n$function$\nselect value::timestamptz\n\n$function$","CREATE\nOR REPLACE FUNCTION public.mt_immutable_time(value text) RETURNS time without time zone LANGUAGE sql IMMUTABLE AS\n$function$\nselect value::time\n\n$function$","CREATE\nOR REPLACE FUNCTION public.mt_immutable_date(value text) RETURNS date LANGUAGE sql IMMUTABLE AS\n$function$\nselect value::date\n\n$function$","CREATE\nOR REPLACE FUNCTION public.mt_grams_vector(text)\n        RETURNS tsvector\n        LANGUAGE plpgsql\n        IMMUTABLE STRICT\nAS $function$\nBEGIN\nRETURN (SELECT array_to_string(public.mt_grams_array($1), ' ') ::tsvector);\nEND\n$function$","CREATE\nOR REPLACE FUNCTION public.mt_grams_query(text)\n        RETURNS tsquery\n        LANGUAGE plpgsql\n        IMMUTABLE STRICT\nAS $function$\nBEGIN\nRETURN (SELECT array_to_string(public.mt_grams_array($1), ' & ') ::tsquery);\nEND\n$function$","CREATE\nOR REPLACE FUNCTION public.mt_grams_array(words text)\n        RETURNS text[]\n        LANGUAGE plpgsql\n        IMMUTABLE STRICT\nAS $function$\n        DECLARE\nresult text[];\n        DECLARE\nword text;\n        DECLARE\nclean_word text;\nBEGIN\n                FOREACH\nword IN ARRAY string_to_array(words, ' ')\n                LOOP\n                     clean_word = regexp_replace(word, '[^a-zA-Z0-9]+', '','g');\nFOR i IN 1 .. length(clean_word)\n                     LOOP\n                         result := result || quote_literal(substr(lower(clean_word), i, 1));\n                         result\n:= result || quote_literal(substr(lower(clean_word), i, 2));\n                         result\n:= result || quote_literal(substr(lower(clean_word), i, 3));\nEND LOOP;\nEND LOOP;\n\nRETURN ARRAY(SELECT DISTINCT e FROM unnest(result) AS a(e) ORDER BY e);\nEND;\n$function$","CREATE OR REPLACE FUNCTION public.mt_jsonb_append(jsonb, text[], jsonb, boolean)\n    RETURNS jsonb\n    LANGUAGE plpgsql\nAS $function$\nDECLARE\n    retval ALIAS FOR $1;\n    location ALIAS FOR $2;\n    val ALIAS FOR $3;\n    if_not_exists ALIAS FOR $4;\n    tmp_value jsonb;\nBEGIN\n    tmp_value = retval #> location;\n    IF tmp_value IS NOT NULL AND jsonb_typeof(tmp_value) = 'array' THEN\n        CASE\n            WHEN NOT if_not_exists THEN\n                retval = jsonb_set(retval, location, tmp_value || val, FALSE);\n            WHEN jsonb_typeof(val) = 'object' AND NOT tmp_value @> jsonb_build_array(val) THEN\n                retval = jsonb_set(retval, location, tmp_value || val, FALSE);\n            WHEN jsonb_typeof(val) <> 'object' AND NOT tmp_value @> val THEN\n                retval = jsonb_set(retval, location, tmp_value || val, FALSE);\n            ELSE NULL;\n            END CASE;\n    END IF;\n    RETURN retval;\nEND;\n$function$","CREATE OR REPLACE FUNCTION public.mt_jsonb_copy(jsonb, text[], text[])\n    RETURNS jsonb\n    LANGUAGE plpgsql\nAS $function$\nDECLARE\n    retval ALIAS FOR $1;\n    src_path ALIAS FOR $2;\n    dst_path ALIAS FOR $3;\n    tmp_value jsonb;\nBEGIN\n    tmp_value = retval #> src_path;\n    retval = public.mt_jsonb_fix_null_parent(retval, dst_path);\n    RETURN jsonb_set(retval, dst_path, tmp_value::jsonb, TRUE);\nEND;\n$function$","CREATE OR REPLACE FUNCTION public.mt_jsonb_duplicate(jsonb, text[], jsonb)\nRETURNS jsonb\nLANGUAGE plpgsql\nAS $function$\nDECLARE\n    retval ALIAS FOR $1;\n    location ALIAS FOR $2;\n    targets ALIAS FOR $3;\n    tmp_value jsonb;\n    target_path text[];\n    target text;\nBEGIN\n    FOR target IN SELECT jsonb_array_elements_text(targets)\n    LOOP\n        target_path = public.mt_jsonb_path_to_array(target, '\\.');\n        retval = public.mt_jsonb_copy(retval, location, target_path);\n    END LOOP;\n\n    RETURN retval;\nEND;\n$function$","CREATE OR REPLACE FUNCTION public.mt_jsonb_fix_null_parent(jsonb, text[])\n    RETURNS jsonb\n    LANGUAGE plpgsql\nAS $function$\nDECLARE\nretval ALIAS FOR $1;\n    dst_path ALIAS FOR $2;\n    dst_path_segment text[] = ARRAY[]::text[];\n    dst_path_array_length integer;\n    i integer = 1;\nBEGIN\n    dst_path_array_length = array_length(dst_path, 1);\n    WHILE i <=(dst_path_array_length - 1)\n    LOOP\n        dst_path_segment = dst_path_segment || ARRAY[dst_path[i]];\n        IF retval #> dst_path_segment = 'null'::jsonb THEN\n            retval = jsonb_set(retval, dst_path_segment, '{}'::jsonb, TRUE);\n        END IF;\n        i = i + 1;\n    END LOOP;\n\n    RETURN retval;\nEND;\n$function$","CREATE OR REPLACE FUNCTION public.mt_jsonb_increment(jsonb, text[], numeric)\n    RETURNS jsonb\n    LANGUAGE plpgsql\nAS $function$\nDECLARE\nretval ALIAS FOR $1;\n    location ALIAS FOR $2;\n    increment_value ALIAS FOR $3;\n    tmp_value jsonb;\nBEGIN\n    tmp_value = retval #> location;\n    IF tmp_value IS NULL THEN\n        tmp_value = to_jsonb(0);\nEND IF;\n\nRETURN jsonb_set(retval, location, to_jsonb(tmp_value::numeric + increment_value), TRUE);\nEND;\n$function$","CREATE OR REPLACE FUNCTION public.mt_jsonb_insert(jsonb, text[], jsonb, integer, boolean)\n    RETURNS jsonb\n    LANGUAGE plpgsql\nAS $function$\nDECLARE\n    retval ALIAS FOR $1;\n    location ALIAS FOR $2;\n    val ALIAS FOR $3;\n    elm_index ALIAS FOR $4;\n    if_not_exists ALIAS FOR $5;\n    tmp_value jsonb;\nBEGIN\n    tmp_value = retval #> location;\n    IF tmp_value IS NOT NULL AND jsonb_typeof(tmp_value) = 'array' THEN\n        IF elm_index IS NULL THEN\n            elm_index = jsonb_array_length(tmp_value) + 1;\n        END IF;\n        CASE\n            WHEN NOT if_not_exists THEN\n                retval = jsonb_insert(retval, location || elm_index::text, val);\n            WHEN jsonb_typeof(val) = 'object' AND NOT tmp_value @> jsonb_build_array(val) THEN\n                retval = jsonb_insert(retval, location || elm_index::text, val);\n            WHEN jsonb_typeof(val) <> 'object' AND NOT tmp_value @> val THEN\n                retval = jsonb_insert(retval, location || elm_index::text, val);\n            ELSE NULL;\n        END CASE;\n    END IF;\n    RETURN retval;\nEND;\n$function$","CREATE OR REPLACE FUNCTION public.mt_jsonb_move(jsonb, text[], text)\n    RETURNS jsonb\n    LANGUAGE plpgsql\nAS $function$\nDECLARE\n    retval ALIAS FOR $1;\n    src_path ALIAS FOR $2;\n    dst_name ALIAS FOR $3;\n    dst_path text[];\n    tmp_value jsonb;\nBEGIN\n    tmp_value = retval #> src_path;\n    retval = retval #- src_path;\n    dst_path = src_path;\n    dst_path[array_length(dst_path, 1)] = dst_name;\n    retval = public.mt_jsonb_fix_null_parent(retval, dst_path);\n    RETURN jsonb_set(retval, dst_path, tmp_value, TRUE);\nEND;\n$function$","CREATE OR REPLACE FUNCTION public.mt_jsonb_path_to_array(text, character)\n    RETURNS text[]\n    LANGUAGE plpgsql\nAS $function$\nDECLARE\n    location ALIAS FOR $1;\n    regex_pattern ALIAS FOR $2;\nBEGIN\nRETURN regexp_split_to_array(location, regex_pattern)::text[];\nEND;\n$function$","CREATE OR REPLACE FUNCTION public.mt_jsonb_remove(jsonb, text[], jsonb)\n    RETURNS jsonb\n    LANGUAGE plpgsql\nAS $function$\nDECLARE\n    retval ALIAS FOR $1;\n    location ALIAS FOR $2;\n    val ALIAS FOR $3;\n    tmp_value jsonb;\nBEGIN\n    tmp_value = retval #> location;\n    IF tmp_value IS NOT NULL AND jsonb_typeof(tmp_value) = 'array' THEN\n        tmp_value =(SELECT jsonb_agg(elem)\n        FROM jsonb_array_elements(tmp_value) AS elem\n        WHERE elem <> val);\n\n        IF tmp_value IS NULL THEN\n            tmp_value = '[]'::jsonb;\n        END IF;\n    END IF;\n    RETURN jsonb_set(retval, location, tmp_value, FALSE);\nEND;\n$function$","CREATE OR REPLACE FUNCTION public.mt_jsonb_patch(jsonb, jsonb)\n    RETURNS jsonb\n    LANGUAGE plpgsql\nAS $function$\nDECLARE\n    retval ALIAS FOR $1;\n    patchset ALIAS FOR $2;\n    patch jsonb;\n    patch_path text[];\n    value jsonb;\nBEGIN\n    FOR patch IN SELECT * from jsonb_array_elements(patchset)\n    LOOP\n        patch_path = public.mt_jsonb_path_to_array((patch->>'path')::text, '\\.');\n\n        CASE patch->>'type'\n            WHEN 'set' THEN\n                retval = jsonb_set(retval, patch_path,(patch->'value')::jsonb, TRUE);\n        WHEN 'delete' THEN\n                retval = retval#-patch_path;\n        WHEN 'append' THEN\n                retval = public.mt_jsonb_append(retval, patch_path,(patch->'value')::jsonb, FALSE);\n        WHEN 'append_if_not_exists' THEN\n                retval = public.mt_jsonb_append(retval, patch_path,(patch->'value')::jsonb, TRUE);\n        WHEN 'insert' THEN\n                retval = public.mt_jsonb_insert(retval, patch_path,(patch->'value')::jsonb,(patch->>'index')::integer, FALSE);\n        WHEN 'insert_if_not_exists' THEN\n                retval = public.mt_jsonb_insert(retval, patch_path,(patch->'value')::jsonb,(patch->>'index')::integer, TRUE);\n        WHEN 'remove' THEN\n                retval = public.mt_jsonb_remove(retval, patch_path,(patch->'value')::jsonb);\n        WHEN 'duplicate' THEN\n                retval = public.mt_jsonb_duplicate(retval, patch_path,(patch->'targets')::jsonb);\n        WHEN 'rename' THEN\n                retval = public.mt_jsonb_move(retval, patch_path,(patch->>'to')::text);\n        WHEN 'increment' THEN\n                retval = public.mt_jsonb_increment(retval, patch_path,(patch->>'increment')::numeric);\n        WHEN 'increment_float' THEN\n                retval = public.mt_jsonb_increment(retval, patch_path,(patch->>'increment')::numeric);\n        ELSE NULL;\n        END CASE;\n    END LOOP;\n    RETURN retval;\nEND;\n$function$"]
2025-01-23 08:09:36.046 +00:00 [INF] Batch execution completed (duration=101ms): ["\nselect column_name, data_type, character_maximum_length, udt_name\nfrom information_schema.columns where table_schema = $1 and table_name = $2\norder by ordinal_position","select kcu.column_name as key_column\nfrom information_schema.table_constraints tco\n         join information_schema.key_column_usage kcu\n              on kcu.constraint_name = tco.constraint_name\n                  and kcu.constraint_schema = tco.constraint_schema\n                  and kcu.constraint_name = tco.constraint_name\nwhere tco.constraint_type = 'PRIMARY KEY' and kcu.table_schema = $1 and kcu.table_name = $2\norder by kcu.ordinal_position","SELECT *\nFROM (\n    SELECT\n      R.rolname                AS user_name,\n      ns.nspname               AS schema_name,\n      pg_catalog.textin(pg_catalog.regclassout(idx.indrelid :: REGCLASS)) AS table_name,\n      i.relname                AS index_name,\n      pg_get_indexdef(i.oid) as ddl,\n      idx.indisunique          AS is_unique,\n      idx.indisprimary         AS is_primary,\n      am.amname                AS index_type,\n      idx.indkey,\n           ARRAY(\n               SELECT pg_get_indexdef(idx.indexrelid, k + 1, TRUE)\n               FROM\n                 generate_subscripts(idx.indkey, 1) AS k\n               ORDER BY k\n           ) AS index_keys,\n      (idx.indexprs IS NOT NULL) OR (idx.indkey::int[] @> array[0]) AS is_functional,\n      idx.indpred IS NOT NULL AS is_partial\n    FROM pg_index AS idx\n      JOIN pg_class AS i\n        ON i.oid = idx.indexrelid\n      JOIN pg_am AS am\n        ON i.relam = am.oid\n      JOIN pg_namespace AS NS ON i.relnamespace = NS.OID\n      JOIN pg_roles AS R ON i.relowner = r.oid\n    WHERE\n      nspname = $1 AND\n      NOT nspname LIKE 'pg%'\n) ind\nWHERE\n      ind.table_name = $2 OR\n      ind.table_name = $3","SELECT c.conname                                     AS constraint_name,\n       c.contype                                     AS constraint_type,\n       sch.nspname                                   AS schema_name,\n       tbl.relname                                   AS table_name,\n       ARRAY_AGG(col.attname ORDER BY u.attposition) AS columns,\n       pg_get_constraintdef(c.oid)                   AS definition\nFROM pg_constraint c\n       JOIN LATERAL UNNEST(c.conkey) WITH ORDINALITY AS u(attnum, attposition) ON TRUE\n       JOIN pg_class tbl ON tbl.oid = c.conrelid\n       JOIN pg_namespace sch ON sch.oid = tbl.relnamespace\n       JOIN pg_attribute col ON (col.attrelid = tbl.oid AND col.attnum = u.attnum)\nWHERE\n\tc.contype = 'f' and\n\tsch.nspname = $1 and\n\ttbl.relname = $2\nGROUP BY constraint_name, constraint_type, schema_name, table_name, definition","SHOW max_identifier_length","select\n    col.column_name,\n    partition_strategy\nfrom\n    (select\n         partrelid,\n         partnatts,\n         case partstrat\n             when 'l' then 'list'\n             when 'h' then 'hash'\n             when 'r' then 'range' end as partition_strategy,\n         unnest(partattrs) column_index\n     from\n         pg_partitioned_table) pt\n        join\n    pg_class par\n    on\n            par.oid = pt.partrelid\n        join\n    information_schema.columns col\n    on\n                col.table_schema = par.relnamespace::regnamespace::text\n            and col.table_name = par.relname\n            and ordinal_position = pt.column_index\nwhere\n    col.table_schema = $1 and table_name = $2\norder by column_index","select pt.relname as partition_name,\n          pg_get_expr(pt.relpartbound, pt.oid, true) as partition_expression\n   from pg_class base_tb\n            join pg_inherits i on i.inhparent = base_tb.oid\n            join pg_class pt on pt.oid = i.inhrelid\n   where base_tb.relname = $1 and base_tb.relnamespace = $2::regnamespace::oid","SELECT pg_get_functiondef(pg_proc.oid)\nFROM pg_proc JOIN pg_namespace as ns ON pg_proc.pronamespace = ns.oid WHERE ns.nspname = $1 and proname = $2","SELECT format('DROP FUNCTION IF EXISTS %s.%s(%s);'\n             ,n.nspname\n             ,p.proname\n             ,pg_get_function_identity_arguments(p.oid))\nFROM   pg_proc p\nLEFT JOIN pg_catalog.pg_namespace n ON n.oid = p.pronamespace\nWHERE  p.proname = $1\nAND    n.nspname = $2","SELECT pg_get_functiondef(pg_proc.oid)\nFROM pg_proc JOIN pg_namespace as ns ON pg_proc.pronamespace = ns.oid WHERE ns.nspname = $1 and proname = $2","SELECT format('DROP FUNCTION IF EXISTS %s.%s(%s);'\n             ,n.nspname\n             ,p.proname\n             ,pg_get_function_identity_arguments(p.oid))\nFROM   pg_proc p\nLEFT JOIN pg_catalog.pg_namespace n ON n.oid = p.pronamespace\nWHERE  p.proname = $1\nAND    n.nspname = $2","SELECT pg_get_functiondef(pg_proc.oid)\nFROM pg_proc JOIN pg_namespace as ns ON pg_proc.pronamespace = ns.oid WHERE ns.nspname = $1 and proname = $2","SELECT format('DROP FUNCTION IF EXISTS %s.%s(%s);'\n             ,n.nspname\n             ,p.proname\n             ,pg_get_function_identity_arguments(p.oid))\nFROM   pg_proc p\nLEFT JOIN pg_catalog.pg_namespace n ON n.oid = p.pronamespace\nWHERE  p.proname = $1\nAND    n.nspname = $2"]
2025-01-23 08:09:36.068 +00:00 [INF] Executed schema update SQL:
DROP TABLE IF EXISTS public.mt_doc_product CASCADE;
CREATE TABLE public.mt_doc_product (
    id                  uuid                        NOT NULL,
    data                jsonb                       NOT NULL,
    mt_last_modified    timestamp with time zone    NULL DEFAULT (transaction_timestamp()),
    mt_version          uuid                        NOT NULL DEFAULT (md5(random()::text || clock_timestamp()::text)::uuid),
    mt_dotnet_type      varchar                     NULL,
CONSTRAINT pkey_mt_doc_product_id PRIMARY KEY (id)
);

CREATE OR REPLACE FUNCTION public.mt_upsert_product(doc JSONB, docDotNetType varchar, docId uuid, docVersion uuid) RETURNS UUID LANGUAGE plpgsql SECURITY INVOKER AS $function$
DECLARE
  final_version uuid;
BEGIN
INSERT INTO public.mt_doc_product ("data", "mt_dotnet_type", "id", "mt_version", mt_last_modified) VALUES (doc, docDotNetType, docId, docVersion, transaction_timestamp())
  ON CONFLICT (id)
  DO UPDATE SET "data" = doc, "mt_dotnet_type" = docDotNetType, "mt_version" = docVersion, mt_last_modified = transaction_timestamp();

  SELECT mt_version FROM public.mt_doc_product into final_version WHERE id = docId ;
  RETURN final_version;
END;
$function$;


CREATE OR REPLACE FUNCTION public.mt_insert_product(doc JSONB, docDotNetType varchar, docId uuid, docVersion uuid) RETURNS UUID LANGUAGE plpgsql SECURITY INVOKER AS $function$
BEGIN
INSERT INTO public.mt_doc_product ("data", "mt_dotnet_type", "id", "mt_version", mt_last_modified) VALUES (doc, docDotNetType, docId, docVersion, transaction_timestamp());

  RETURN docVersion;
END;
$function$;


CREATE OR REPLACE FUNCTION public.mt_update_product(doc JSONB, docDotNetType varchar, docId uuid, docVersion uuid) RETURNS UUID LANGUAGE plpgsql SECURITY INVOKER AS $function$
DECLARE
  final_version uuid;
BEGIN
  UPDATE public.mt_doc_product SET "data" = doc, "mt_dotnet_type" = docDotNetType, "mt_version" = docVersion, mt_last_modified = transaction_timestamp() where id = docId;

  SELECT mt_version FROM public.mt_doc_product into final_version WHERE id = docId ;
  RETURN final_version;
END;
$function$;


2025-01-23 08:09:36.095 +00:00 [INF] Batch execution completed (duration=25ms): ["DROP TABLE IF EXISTS public.mt_doc_product CASCADE","CREATE TABLE public.mt_doc_product (\n    id                  uuid                        NOT NULL,\n    data                jsonb                       NOT NULL,\n    mt_last_modified    timestamp with time zone    NULL DEFAULT (transaction_timestamp()),\n    mt_version          uuid                        NOT NULL DEFAULT (md5(random()::text || clock_timestamp()::text)::uuid),\n    mt_dotnet_type      varchar                     NULL,\nCONSTRAINT pkey_mt_doc_product_id PRIMARY KEY (id)\n)","CREATE OR REPLACE FUNCTION public.mt_upsert_product(doc JSONB, docDotNetType varchar, docId uuid, docVersion uuid) RETURNS UUID LANGUAGE plpgsql SECURITY INVOKER AS $function$\nDECLARE\n  final_version uuid;\nBEGIN\nINSERT INTO public.mt_doc_product (\"data\", \"mt_dotnet_type\", \"id\", \"mt_version\", mt_last_modified) VALUES (doc, docDotNetType, docId, docVersion, transaction_timestamp())\n  ON CONFLICT (id)\n  DO UPDATE SET \"data\" = doc, \"mt_dotnet_type\" = docDotNetType, \"mt_version\" = docVersion, mt_last_modified = transaction_timestamp();\n\n  SELECT mt_version FROM public.mt_doc_product into final_version WHERE id = docId ;\n  RETURN final_version;\nEND;\n$function$","CREATE OR REPLACE FUNCTION public.mt_insert_product(doc JSONB, docDotNetType varchar, docId uuid, docVersion uuid) RETURNS UUID LANGUAGE plpgsql SECURITY INVOKER AS $function$\nBEGIN\nINSERT INTO public.mt_doc_product (\"data\", \"mt_dotnet_type\", \"id\", \"mt_version\", mt_last_modified) VALUES (doc, docDotNetType, docId, docVersion, transaction_timestamp());\n\n  RETURN docVersion;\nEND;\n$function$","CREATE OR REPLACE FUNCTION public.mt_update_product(doc JSONB, docDotNetType varchar, docId uuid, docVersion uuid) RETURNS UUID LANGUAGE plpgsql SECURITY INVOKER AS $function$\nDECLARE\n  final_version uuid;\nBEGIN\n  UPDATE public.mt_doc_product SET \"data\" = doc, \"mt_dotnet_type\" = docDotNetType, \"mt_version\" = docVersion, mt_last_modified = transaction_timestamp() where id = docId;\n\n  SELECT mt_version FROM public.mt_doc_product into final_version WHERE id = docId ;\n  RETURN final_version;\nEND;\n$function$"]
2025-01-23 08:09:36.179 +00:00 [INF] Command execution completed (duration=34ms): select d.id, d.data from public.mt_doc_product as d
2025-01-23 08:09:38.495 +00:00 [INF] Setting HTTP status code 200.
2025-01-23 08:09:38.506 +00:00 [INF] Writing value of type 'GetProductsResponse' as Json.
2025-01-23 08:09:38.524 +00:00 [INF] Executed endpoint 'HTTP: GET /products'
2025-01-23 08:09:38.531 +00:00 [INF] Request finished HTTP/1.1 GET https://localhost:9999/products - 200 null application/json; charset=utf-8 19264.3483ms
2025-01-23 08:09:46.608 +00:00 [INF] Request starting HTTP/1.1 POST https://localhost:9999/products - application/json 269
2025-01-23 08:09:46.609 +00:00 [INF] Executing endpoint 'HTTP: POST /products'
2025-01-23 08:09:46.649 +00:00 [INF] CreateProduct start.Handle called with {"Name":"Poduct docker","Category":["h1","h2"],"Description":" this test product from hello","ImageFile":"Hello.png","Price":9999,"$type":"CreateProductCommand"}
2025-01-23 08:10:28.319 +00:00 [INF] Start
2025-01-23 08:10:28.546 +00:00 [INF] Command execution completed (duration=13ms): select public.mt_upsert_product($1,$2,$3,$4)
2025-01-23 08:10:28.562 +00:00 [INF] ENd {"Id":"01949236-6ecc-4b85-81f0-184ab28c0815","Name":"Poduct docker","Category":["h1","h2"],"Description":" this test product from hello","ImageFile":"Hello.png","Price":9999,"$type":"Product"}
2025-01-23 08:10:28.563 +00:00 [INF] CreateProduct end.Handle called with {"Id":"01949236-6ecc-4b85-81f0-184ab28c0815","$type":"CreateProductResult"}
2025-01-23 08:10:28.566 +00:00 [INF] Setting HTTP status code 201.
2025-01-23 08:10:28.569 +00:00 [INF] Writing value of type 'CreateProductResponse' as Json.
2025-01-23 08:10:28.572 +00:00 [INF] Executed endpoint 'HTTP: POST /products'
2025-01-23 08:10:28.573 +00:00 [INF] Request finished HTTP/1.1 POST https://localhost:9999/products - 201 null application/json; charset=utf-8 41814.4473ms
2025-01-23 08:10:39.425 +00:00 [INF] Request starting HTTP/1.1 POST https://localhost:9999/products - application/json 267
2025-01-23 08:10:39.426 +00:00 [INF] Executing endpoint 'HTTP: POST /products'
2025-01-23 08:10:39.428 +00:00 [INF] CreateProduct start.Handle called with {"Name":"Poduct grpc","Category":["h1","h2"],"Description":" this test product from hello","ImageFile":"Hello.png","Price":9999,"$type":"CreateProductCommand"}
2025-01-23 08:10:50.887 +00:00 [INF] Start
2025-01-23 08:10:50.955 +00:00 [INF] Command execution completed (duration=25ms): select public.mt_upsert_product($1,$2,$3,$4)
2025-01-23 08:10:50.963 +00:00 [INF] ENd {"Id":"01949236-c690-4b8a-954c-7b3f6fba34d5","Name":"Poduct grpc","Category":["h1","h2"],"Description":" this test product from hello","ImageFile":"Hello.png","Price":9999,"$type":"Product"}
2025-01-23 08:10:50.964 +00:00 [INF] CreateProduct end.Handle called with {"Id":"01949236-c690-4b8a-954c-7b3f6fba34d5","$type":"CreateProductResult"}
2025-01-23 08:10:50.964 +00:00 [INF] Setting HTTP status code 201.
2025-01-23 08:10:50.965 +00:00 [INF] Writing value of type 'CreateProductResponse' as Json.
2025-01-23 08:10:50.965 +00:00 [INF] Executed endpoint 'HTTP: POST /products'
2025-01-23 08:10:50.966 +00:00 [INF] Request finished HTTP/1.1 POST https://localhost:9999/products - 201 null application/json; charset=utf-8 11540.5009ms
2025-01-23 08:10:56.312 +00:00 [INF] Request starting HTTP/1.1 GET https://localhost:9999/products - application/json 267
2025-01-23 08:10:56.313 +00:00 [INF] Executing endpoint 'HTTP: GET /products'
2025-01-23 08:11:00.653 +00:00 [INF] GetProductsQueryHandler.Handle called with {"$type":"GetProductsQuery"}
2025-01-23 08:11:00.712 +00:00 [INF] Command execution completed (duration=57ms): select d.id, d.data from public.mt_doc_product as d
2025-01-23 08:11:00.713 +00:00 [INF] Setting HTTP status code 200.
2025-01-23 08:11:00.714 +00:00 [INF] Writing value of type 'GetProductsResponse' as Json.
2025-01-23 08:11:00.720 +00:00 [INF] Executed endpoint 'HTTP: GET /products'
2025-01-23 08:11:00.721 +00:00 [INF] Request finished HTTP/1.1 GET https://localhost:9999/products - 200 null application/json; charset=utf-8 4353.4567ms
2025-01-23 08:11:14.585 +00:00 [INF] Request starting HTTP/2 GET https://localhost:9999/products - null null
2025-01-23 08:11:14.586 +00:00 [INF] Executing endpoint 'HTTP: GET /products'
2025-01-23 08:11:17.854 +00:00 [INF] GetProductsQueryHandler.Handle called with {"$type":"GetProductsQuery"}
2025-01-23 08:11:17.952 +00:00 [INF] Command execution completed (duration=29ms): select d.id, d.data from public.mt_doc_product as d
2025-01-23 08:11:17.953 +00:00 [INF] Setting HTTP status code 200.
2025-01-23 08:11:17.953 +00:00 [INF] Writing value of type 'GetProductsResponse' as Json.
2025-01-23 08:11:17.955 +00:00 [INF] Executed endpoint 'HTTP: GET /products'
2025-01-23 08:11:17.955 +00:00 [INF] Request finished HTTP/2 GET https://localhost:9999/products - 200 null application/json; charset=utf-8 3370.4183ms
2025-01-23 08:12:40.907 +00:00 [WRN] Overriding HTTP_PORTS '8080' and HTTPS_PORTS ''. Binding to values defined by URLS instead '"https://+:9999;http://+:9998"'.
2025-01-23 08:12:41.038 +00:00 [WRN] The WebRootPath was not found: /app/wwwroot. Static files may be unavailable.
2025-01-23 08:12:41.049 +00:00 [WRN] Overriding address(es) '"https://+:9999, http://+:9998"'. Binding to endpoints defined via IConfiguration and/or UseKestrel() instead.
2025-01-23 08:12:41.272 +00:00 [INF] Now listening on: http://0.0.0.0:8080
2025-01-23 08:12:41.273 +00:00 [INF] Now listening on: https://0.0.0.0:8081
2025-01-23 08:12:41.274 +00:00 [INF] Application started. Press Ctrl+C to shut down.
2025-01-23 08:12:41.275 +00:00 [INF] Hosting environment: Production
2025-01-23 08:12:41.275 +00:00 [INF] Content root path: /app
2025-01-23 08:12:48.264 +00:00 [INF] Request starting HTTP/2 GET https://localhost:9999/ - null null
2025-01-23 08:12:48.392 +00:00 [INF] Executing endpoint 'HTTP: GET /'
2025-01-23 08:12:48.395 +00:00 [INF] Executed endpoint 'HTTP: GET /'
2025-01-23 08:12:48.397 +00:00 [INF] Request finished HTTP/2 GET https://localhost:9999/ - 200 null text/plain; charset=utf-8 134.0399ms
2025-01-23 08:12:52.569 +00:00 [INF] Request starting HTTP/2 GET https://localhost:9999/products - null null
2025-01-23 08:12:52.571 +00:00 [INF] Executing endpoint 'HTTP: GET /products'
2025-01-23 08:12:57.039 +00:00 [INF] GetProductsQueryHandler.Handle called with {"$type":"GetProductsQuery"}
2025-01-23 08:13:00.659 +00:00 [INF] Batch execution completed (duration=47ms): ["\nSELECT pg_get_functiondef(pg_proc.oid)\nFROM pg_proc JOIN pg_namespace as ns ON pg_proc.pronamespace = ns.oid WHERE ns.nspname = $1 and proname = $2","SELECT format('DROP FUNCTION IF EXISTS %s.%s(%s);'\n             ,n.nspname\n             ,p.proname\n             ,pg_get_function_identity_arguments(p.oid))\nFROM   pg_proc p\nLEFT JOIN pg_catalog.pg_namespace n ON n.oid = p.pronamespace\nWHERE  p.proname = $1\nAND    n.nspname = $2","SELECT pg_get_functiondef(pg_proc.oid)\nFROM pg_proc JOIN pg_namespace as ns ON pg_proc.pronamespace = ns.oid WHERE ns.nspname = $1 and proname = $2","SELECT format('DROP FUNCTION IF EXISTS %s.%s(%s);'\n             ,n.nspname\n             ,p.proname\n             ,pg_get_function_identity_arguments(p.oid))\nFROM   pg_proc p\nLEFT JOIN pg_catalog.pg_namespace n ON n.oid = p.pronamespace\nWHERE  p.proname = $1\nAND    n.nspname = $2","SELECT pg_get_functiondef(pg_proc.oid)\nFROM pg_proc JOIN pg_namespace as ns ON pg_proc.pronamespace = ns.oid WHERE ns.nspname = $1 and proname = $2","SELECT format('DROP FUNCTION IF EXISTS %s.%s(%s);'\n             ,n.nspname\n             ,p.proname\n             ,pg_get_function_identity_arguments(p.oid))\nFROM   pg_proc p\nLEFT JOIN pg_catalog.pg_namespace n ON n.oid = p.pronamespace\nWHERE  p.proname = $1\nAND    n.nspname = $2","SELECT pg_get_functiondef(pg_proc.oid)\nFROM pg_proc JOIN pg_namespace as ns ON pg_proc.pronamespace = ns.oid WHERE ns.nspname = $1 and proname = $2","SELECT format('DROP FUNCTION IF EXISTS %s.%s(%s);'\n             ,n.nspname\n             ,p.proname\n             ,pg_get_function_identity_arguments(p.oid))\nFROM   pg_proc p\nLEFT JOIN pg_catalog.pg_namespace n ON n.oid = p.pronamespace\nWHERE  p.proname = $1\nAND    n.nspname = $2","SELECT pg_get_functiondef(pg_proc.oid)\nFROM pg_proc JOIN pg_namespace as ns ON pg_proc.pronamespace = ns.oid WHERE ns.nspname = $1 and proname = $2","SELECT format('DROP FUNCTION IF EXISTS %s.%s(%s);'\n             ,n.nspname\n             ,p.proname\n             ,pg_get_function_identity_arguments(p.oid))\nFROM   pg_proc p\nLEFT JOIN pg_catalog.pg_namespace n ON n.oid = p.pronamespace\nWHERE  p.proname = $1\nAND    n.nspname = $2","SELECT pg_get_functiondef(pg_proc.oid)\nFROM pg_proc JOIN pg_namespace as ns ON pg_proc.pronamespace = ns.oid WHERE ns.nspname = $1 and proname = $2","SELECT format('DROP FUNCTION IF EXISTS %s.%s(%s);'\n             ,n.nspname\n             ,p.proname\n             ,pg_get_function_identity_arguments(p.oid))\nFROM   pg_proc p\nLEFT JOIN pg_catalog.pg_namespace n ON n.oid = p.pronamespace\nWHERE  p.proname = $1\nAND    n.nspname = $2","SELECT pg_get_functiondef(pg_proc.oid)\nFROM pg_proc JOIN pg_namespace as ns ON pg_proc.pronamespace = ns.oid WHERE ns.nspname = $1 and proname = $2","SELECT format('DROP FUNCTION IF EXISTS %s.%s(%s);'\n             ,n.nspname\n             ,p.proname\n             ,pg_get_function_identity_arguments(p.oid))\nFROM   pg_proc p\nLEFT JOIN pg_catalog.pg_namespace n ON n.oid = p.pronamespace\nWHERE  p.proname = $1\nAND    n.nspname = $2","SELECT pg_get_functiondef(pg_proc.oid)\nFROM pg_proc JOIN pg_namespace as ns ON pg_proc.pronamespace = ns.oid WHERE ns.nspname = $1 and proname = $2","SELECT format('DROP FUNCTION IF EXISTS %s.%s(%s);'\n             ,n.nspname\n             ,p.proname\n             ,pg_get_function_identity_arguments(p.oid))\nFROM   pg_proc p\nLEFT JOIN pg_catalog.pg_namespace n ON n.oid = p.pronamespace\nWHERE  p.proname = $1\nAND    n.nspname = $2","SELECT pg_get_functiondef(pg_proc.oid)\nFROM pg_proc JOIN pg_namespace as ns ON pg_proc.pronamespace = ns.oid WHERE ns.nspname = $1 and proname = $2","SELECT format('DROP FUNCTION IF EXISTS %s.%s(%s);'\n             ,n.nspname\n             ,p.proname\n             ,pg_get_function_identity_arguments(p.oid))\nFROM   pg_proc p\nLEFT JOIN pg_catalog.pg_namespace n ON n.oid = p.pronamespace\nWHERE  p.proname = $1\nAND    n.nspname = $2","SELECT pg_get_functiondef(pg_proc.oid)\nFROM pg_proc JOIN pg_namespace as ns ON pg_proc.pronamespace = ns.oid WHERE ns.nspname = $1 and proname = $2","SELECT format('DROP FUNCTION IF EXISTS %s.%s(%s);'\n             ,n.nspname\n             ,p.proname\n             ,pg_get_function_identity_arguments(p.oid))\nFROM   pg_proc p\nLEFT JOIN pg_catalog.pg_namespace n ON n.oid = p.pronamespace\nWHERE  p.proname = $1\nAND    n.nspname = $2","SELECT pg_get_functiondef(pg_proc.oid)\nFROM pg_proc JOIN pg_namespace as ns ON pg_proc.pronamespace = ns.oid WHERE ns.nspname = $1 and proname = $2","SELECT format('DROP FUNCTION IF EXISTS %s.%s(%s);'\n             ,n.nspname\n             ,p.proname\n             ,pg_get_function_identity_arguments(p.oid))\nFROM   pg_proc p\nLEFT JOIN pg_catalog.pg_namespace n ON n.oid = p.pronamespace\nWHERE  p.proname = $1\nAND    n.nspname = $2","SELECT pg_get_functiondef(pg_proc.oid)\nFROM pg_proc JOIN pg_namespace as ns ON pg_proc.pronamespace = ns.oid WHERE ns.nspname = $1 and proname = $2","SELECT format('DROP FUNCTION IF EXISTS %s.%s(%s);'\n             ,n.nspname\n             ,p.proname\n             ,pg_get_function_identity_arguments(p.oid))\nFROM   pg_proc p\nLEFT JOIN pg_catalog.pg_namespace n ON n.oid = p.pronamespace\nWHERE  p.proname = $1\nAND    n.nspname = $2","SELECT pg_get_functiondef(pg_proc.oid)\nFROM pg_proc JOIN pg_namespace as ns ON pg_proc.pronamespace = ns.oid WHERE ns.nspname = $1 and proname = $2","SELECT format('DROP FUNCTION IF EXISTS %s.%s(%s);'\n             ,n.nspname\n             ,p.proname\n             ,pg_get_function_identity_arguments(p.oid))\nFROM   pg_proc p\nLEFT JOIN pg_catalog.pg_namespace n ON n.oid = p.pronamespace\nWHERE  p.proname = $1\nAND    n.nspname = $2","SELECT pg_get_functiondef(pg_proc.oid)\nFROM pg_proc JOIN pg_namespace as ns ON pg_proc.pronamespace = ns.oid WHERE ns.nspname = $1 and proname = $2","SELECT format('DROP FUNCTION IF EXISTS %s.%s(%s);'\n             ,n.nspname\n             ,p.proname\n             ,pg_get_function_identity_arguments(p.oid))\nFROM   pg_proc p\nLEFT JOIN pg_catalog.pg_namespace n ON n.oid = p.pronamespace\nWHERE  p.proname = $1\nAND    n.nspname = $2","SELECT pg_get_functiondef(pg_proc.oid)\nFROM pg_proc JOIN pg_namespace as ns ON pg_proc.pronamespace = ns.oid WHERE ns.nspname = $1 and proname = $2","SELECT format('DROP FUNCTION IF EXISTS %s.%s(%s);'\n             ,n.nspname\n             ,p.proname\n             ,pg_get_function_identity_arguments(p.oid))\nFROM   pg_proc p\nLEFT JOIN pg_catalog.pg_namespace n ON n.oid = p.pronamespace\nWHERE  p.proname = $1\nAND    n.nspname = $2","SELECT pg_get_functiondef(pg_proc.oid)\nFROM pg_proc JOIN pg_namespace as ns ON pg_proc.pronamespace = ns.oid WHERE ns.nspname = $1 and proname = $2","SELECT format('DROP FUNCTION IF EXISTS %s.%s(%s);'\n             ,n.nspname\n             ,p.proname\n             ,pg_get_function_identity_arguments(p.oid))\nFROM   pg_proc p\nLEFT JOIN pg_catalog.pg_namespace n ON n.oid = p.pronamespace\nWHERE  p.proname = $1\nAND    n.nspname = $2","SELECT pg_get_functiondef(pg_proc.oid)\nFROM pg_proc JOIN pg_namespace as ns ON pg_proc.pronamespace = ns.oid WHERE ns.nspname = $1 and proname = $2","SELECT format('DROP FUNCTION IF EXISTS %s.%s(%s);'\n             ,n.nspname\n             ,p.proname\n             ,pg_get_function_identity_arguments(p.oid))\nFROM   pg_proc p\nLEFT JOIN pg_catalog.pg_namespace n ON n.oid = p.pronamespace\nWHERE  p.proname = $1\nAND    n.nspname = $2"]
2025-01-23 08:13:00.740 +00:00 [INF] Batch execution completed (duration=53ms): ["\nselect column_name, data_type, character_maximum_length, udt_name\nfrom information_schema.columns where table_schema = $1 and table_name = $2\norder by ordinal_position","select kcu.column_name as key_column\nfrom information_schema.table_constraints tco\n         join information_schema.key_column_usage kcu\n              on kcu.constraint_name = tco.constraint_name\n                  and kcu.constraint_schema = tco.constraint_schema\n                  and kcu.constraint_name = tco.constraint_name\nwhere tco.constraint_type = 'PRIMARY KEY' and kcu.table_schema = $1 and kcu.table_name = $2\norder by kcu.ordinal_position","SELECT *\nFROM (\n    SELECT\n      R.rolname                AS user_name,\n      ns.nspname               AS schema_name,\n      pg_catalog.textin(pg_catalog.regclassout(idx.indrelid :: REGCLASS)) AS table_name,\n      i.relname                AS index_name,\n      pg_get_indexdef(i.oid) as ddl,\n      idx.indisunique          AS is_unique,\n      idx.indisprimary         AS is_primary,\n      am.amname                AS index_type,\n      idx.indkey,\n           ARRAY(\n               SELECT pg_get_indexdef(idx.indexrelid, k + 1, TRUE)\n               FROM\n                 generate_subscripts(idx.indkey, 1) AS k\n               ORDER BY k\n           ) AS index_keys,\n      (idx.indexprs IS NOT NULL) OR (idx.indkey::int[] @> array[0]) AS is_functional,\n      idx.indpred IS NOT NULL AS is_partial\n    FROM pg_index AS idx\n      JOIN pg_class AS i\n        ON i.oid = idx.indexrelid\n      JOIN pg_am AS am\n        ON i.relam = am.oid\n      JOIN pg_namespace AS NS ON i.relnamespace = NS.OID\n      JOIN pg_roles AS R ON i.relowner = r.oid\n    WHERE\n      nspname = $1 AND\n      NOT nspname LIKE 'pg%'\n) ind\nWHERE\n      ind.table_name = $2 OR\n      ind.table_name = $3","SELECT c.conname                                     AS constraint_name,\n       c.contype                                     AS constraint_type,\n       sch.nspname                                   AS schema_name,\n       tbl.relname                                   AS table_name,\n       ARRAY_AGG(col.attname ORDER BY u.attposition) AS columns,\n       pg_get_constraintdef(c.oid)                   AS definition\nFROM pg_constraint c\n       JOIN LATERAL UNNEST(c.conkey) WITH ORDINALITY AS u(attnum, attposition) ON TRUE\n       JOIN pg_class tbl ON tbl.oid = c.conrelid\n       JOIN pg_namespace sch ON sch.oid = tbl.relnamespace\n       JOIN pg_attribute col ON (col.attrelid = tbl.oid AND col.attnum = u.attnum)\nWHERE\n\tc.contype = 'f' and\n\tsch.nspname = $1 and\n\ttbl.relname = $2\nGROUP BY constraint_name, constraint_type, schema_name, table_name, definition","SHOW max_identifier_length","select\n    col.column_name,\n    partition_strategy\nfrom\n    (select\n         partrelid,\n         partnatts,\n         case partstrat\n             when 'l' then 'list'\n             when 'h' then 'hash'\n             when 'r' then 'range' end as partition_strategy,\n         unnest(partattrs) column_index\n     from\n         pg_partitioned_table) pt\n        join\n    pg_class par\n    on\n            par.oid = pt.partrelid\n        join\n    information_schema.columns col\n    on\n                col.table_schema = par.relnamespace::regnamespace::text\n            and col.table_name = par.relname\n            and ordinal_position = pt.column_index\nwhere\n    col.table_schema = $1 and table_name = $2\norder by column_index","select pt.relname as partition_name,\n          pg_get_expr(pt.relpartbound, pt.oid, true) as partition_expression\n   from pg_class base_tb\n            join pg_inherits i on i.inhparent = base_tb.oid\n            join pg_class pt on pt.oid = i.inhrelid\n   where base_tb.relname = $1 and base_tb.relnamespace = $2::regnamespace::oid","SELECT pg_get_functiondef(pg_proc.oid)\nFROM pg_proc JOIN pg_namespace as ns ON pg_proc.pronamespace = ns.oid WHERE ns.nspname = $1 and proname = $2","SELECT format('DROP FUNCTION IF EXISTS %s.%s(%s);'\n             ,n.nspname\n             ,p.proname\n             ,pg_get_function_identity_arguments(p.oid))\nFROM   pg_proc p\nLEFT JOIN pg_catalog.pg_namespace n ON n.oid = p.pronamespace\nWHERE  p.proname = $1\nAND    n.nspname = $2","SELECT pg_get_functiondef(pg_proc.oid)\nFROM pg_proc JOIN pg_namespace as ns ON pg_proc.pronamespace = ns.oid WHERE ns.nspname = $1 and proname = $2","SELECT format('DROP FUNCTION IF EXISTS %s.%s(%s);'\n             ,n.nspname\n             ,p.proname\n             ,pg_get_function_identity_arguments(p.oid))\nFROM   pg_proc p\nLEFT JOIN pg_catalog.pg_namespace n ON n.oid = p.pronamespace\nWHERE  p.proname = $1\nAND    n.nspname = $2","SELECT pg_get_functiondef(pg_proc.oid)\nFROM pg_proc JOIN pg_namespace as ns ON pg_proc.pronamespace = ns.oid WHERE ns.nspname = $1 and proname = $2","SELECT format('DROP FUNCTION IF EXISTS %s.%s(%s);'\n             ,n.nspname\n             ,p.proname\n             ,pg_get_function_identity_arguments(p.oid))\nFROM   pg_proc p\nLEFT JOIN pg_catalog.pg_namespace n ON n.oid = p.pronamespace\nWHERE  p.proname = $1\nAND    n.nspname = $2"]
2025-01-23 08:13:00.903 +00:00 [INF] Command execution completed (duration=136ms): select d.id, d.data from public.mt_doc_product as d
2025-01-23 08:13:00.981 +00:00 [INF] Setting HTTP status code 200.
2025-01-23 08:13:00.992 +00:00 [INF] Writing value of type 'GetProductsResponse' as Json.
2025-01-23 08:13:01.029 +00:00 [INF] Executed endpoint 'HTTP: GET /products'
2025-01-23 08:13:01.036 +00:00 [INF] Request finished HTTP/2 GET https://localhost:9999/products - 200 null application/json; charset=utf-8 8383.6585ms
